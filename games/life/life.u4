//
//	Conway's Life, originallly programmed by M. Blecker
//
//	Written by Paul Robson July 2016
//

: initialise 2 1 >port 1 2 >Port 1 1 >port 1 2 >Port ;								// Turn screen and keyboard on ( - )

: key random drop inkey dup 0< if drop self then ;									// Wait for key stroke ( - key)

// Uses 32x32 mode. Top half of page 7 is the 'new' screen.
// For scanning, the challenging bit it is usually stored as mask (e.g. $80) and screen address low byte
// hence the proliferation of over over.

: checkCell 					// (mask address - mask address) of next cell down
	//over over @ or over ! 
	over over @ and if 1 0 +! then 4 + ;

: getCurrentCell over over @ and 0= 0= 1 ! 4 + ;

: aliveLogic 0 @ 2/ 1 = ;
: deadLogic 0 @ 3 = ;
: getNewStatus 1 @ if aliveLogic ; deadLogic ;

: setNextOn over over 132 + @ or over 132 + ! ; // (mask address - ) next page one line down hence 132
	

: moveRight swap 2/ ?dup 0= if 1+ $80 then swap ;

: canOptimise dup @ if 0 ; dup 4 + @ if 0 ; dup 8 + @ if 0 ; 	// if this byte and two below are 0 & mask is 8 or higher optimise out
	over $FC and ;

: countCells 					// (mask address - mask address)
	canOptimise if moveRight ;							// speed up mostly empty screen.

	over over 
	0 0 ! 0 1 ! 										// clear count (0) original (1)

	checkCell checkCell checkCell 12 - moveRight 		// count cells.
	checkCell getCurrentCell checkCell 12 - moveRight
	checkCell checkCell checkCell drop drop
	moveRight 											// move right to next cell.
	getNewStatus if setNextOn then ;

: doCellsToEndOfScreen
	countCells dup 3 ! dup $78 = if ; self

: copy1 dup 128 + @ over ! dup 128 + 0 swap ! 1+ ;		// copy 2nd half of page 7 to first half, clear second half.
: copyRest copy1 dup $78 = if ; self

: oneScreen 	
	$01 $07 doCellsToEndOfScreen drop drop	
	$08 copyRest drop 0 3 !
	;

: __main
	initialise 7 page! 
	clearscreen 

	2 12 !
	1 16 !
	7 20 !

	oneScreen 
	oneScreen 
	oneScreen 
	oneScreen 
	stop
