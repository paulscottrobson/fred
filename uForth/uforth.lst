 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 1 - 7/31/2016 21:04:16


       1/       0 :                     ; *********************************************************************************************************************
       2/       0 :                     ; *********************************************************************************************************************
       3/       0 :                     ;
       4/       0 :                     ;		Core Runtime and Interpreter. Has a collection of 1801 code primitives, the bytecode interpreter and
       5/       0 :                     ;		the FRED display driver. 
       6/       0 :                     ;
       7/       0 :                     ;		Words in core are indicated by double square brackets in the comments, and are extracted from the list file.
       8/       0 :                     ; 		(so memory is not wasted storing the word name)
       9/       0 :                     ;
      10/       0 :                     ; *********************************************************************************************************************
      11/       0 :                     ; *********************************************************************************************************************
      12/       0 :                     
      13/       0 :                     		cpu 1802 									; actually it is a 1801.
      14/       0 :                     
      15/       0 : =0H                 r0 = 0 												; display pointer (R0)
      16/       0 : =1H                 rInterrupt = 1 										; interrupt address (R1)
      17/       0 : =2H                 rRStack = 2 										; return stack (R2)
      18/       0 : =3H                 rDStack = 3 										; data stack (R3)
      19/       0 : =4H                 rProgram = 4 										; program code pointer (R4)
      20/       0 : =5H                 rVariables = 5 										; points to variables (R5)
      21/       0 :                     
      22/       0 : =6H                 r6 = 6												; work registers (R6-R10, can also use RE)
      23/       0 : =7H                 r7 = 7
      24/       0 : =8H                 r8 = 8
      25/       0 : =9H                 r9 = 9
      26/       0 : =AH                 ra = 10
      27/       0 :                     
      28/       0 : =BH                 rCounter = 11 										; interrupt counter (RB, bumps every tick)
      29/       0 : =CH                 rc = 12 											; execute instruction at r4
      30/       0 : =DH                 rd = 13 											; makes instruction byte code
      31/       0 : =EH                 re = 14 											; general temporary register
      32/       0 : =FH                 rf = 15 											; pc register when running 1801 code.
      33/       0 :                     
      34/       0 : =3H                 AudioPort = 3 										; Fred audio port.
      35/       0 :                     
      36/       0 :                     lri 	macro r,n 									; macro to load register.
      37/       0 :                     		ldi (n) & 255
      38/       0 :                     		plo r
      39/       0 :                     		ldi (n) / 256
      40/       0 :                     		phi r
      41/       0 :                     		endm
      42/       0 :                     
      43/       0 : =700H               videoMemory = 0700h 								; 64 x 32 Video RAM. Data memory is in the page below.
      44/       0 : =600H               dataMemory = 0600h									; data memory page.
      45/       0 :                     
      46/       0 : 30 F5               		br 		Boot 								; [[;]] skip over machine code. Also defines return (;) as $00
      47/       2 :                     
      48/       2 :                     ; *********************************************************************************************************************
      49/       2 :                     ;
      50/       2 :                     ;								Forth 1801 assembler primitives (optimisable for 1802)
      51/       2 :                     ;
      52/       2 :                     ;	@,!,+!,1+,1-,2*,2/,+,-,and,or,xor,literal,drop,dup,over,0-,0=,0<,0,1,-1,swap,R>,>R,0>,0BR,;,?DUP,ROT,0>,=,Pick
      53/       2 :                     ;	br,varpage,page!
      54/       2 :                     ; *********************************************************************************************************************
      55/       2 :                     ;					Note some of these drop through, so the order is important in some cases
      56/       2 :                     ;	When changing this code check the position of the GHI R0s in Boot, the first must be in page 0 the second 
      57/       2 :                     ;   in page 1.
      58/       2 :                     ; *********************************************************************************************************************
      59/       2 :                     
      60/       2 : F8 68               FW_In:	ldi 	068h								; [[PORT>]] input from port
 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 2 - 7/31/2016 21:04:16


      61/       4 : 30 08               		br 		FW_IO
      62/       6 : F8 60               FW_Out:	ldi 	060h 								; [[>PORT]] output to port.
      63/       8 :                     
      64/       8 : AE                  FW_IO:	plo 	re 									; save in RE.0
      65/       9 :                     
      66/       9 : 22                  		dec 	rRStack	 							; push $DC (SEP RC) on return stack.
      67/       A : F8 DC               		ldi 	0DCh 								
      68/       C : 52                  		str 	rRStack
      69/       D :                     
      70/       D : 8E                  		glo 	re 									; get instruction base (INP or OUT)
      71/       E : F1                  		or 											; or with the port number
      72/       F : 22                  		dec 	rRStack 							; push on rstack
      73/      10 : 52                  		str 	rRStack
      74/      11 :                     
      75/      11 : FA 08               		ani 	008h 								; if IN, we need the old stack element for the result so we don't 
      76/      13 : 3A 16               		bnz 	__IO_DoIt 							; do this INC, which is throwing away the port address
      77/      15 : 13                  		inc 	rDStack 							; for OUT this leaves the data to be outed which post increments
      78/      16 :                     __IO_DoIt:
      79/      16 : D2                  		sep 	rRStack 							; run the code on the stack.
      80/      17 :                     
      81/      17 :                     ; *********************************************************************************************************************
      82/      17 :                     
      83/      17 :                     FW_Pick:
      84/      17 : 83                  		glo 	rDStack								; add TOS to DStack into RE
      85/      18 : F4                  		add 
      86/      19 : AE                  		plo 	re
      87/      1A : 93                  		ghi 	rDStack
      88/      1B : BE                  		phi 	re
      89/      1C : 4E                  		lda 	re 									; get the picked value
      90/      1D : 53                  		str 	rDStack 							; save at TOS
      91/      1E : DC                  		sep 	rc 									; and exit
      92/      1F :                     
      93/      1F :                     ; *********************************************************************************************************************
      94/      1F :                     
      95/      1F :                     FW_ROT:												; [[ROT]] rotate top 3 n1 n2 n3 -> n2 n3 n1
      96/      1F : 43                  		lda 	rDStack 							; get n3
      97/      20 : AE                  		plo 	re
      98/      21 : F0                  		ldx 										; get n2
      99/      22 : BE                  		phi 	re
     100/      23 : 8E                  		glo 	re 									; get n3
     101/      24 : 53                  		str 	rDStack 							; save where n2 was
     102/      25 : 13                  		inc 	rDStack 							; point to n1
     103/      26 : F0                  		ldx 										; read n1
     104/      27 : AE                  		plo 	re 									; save in RE.0
     105/      28 : 9E                  		ghi 	re 									; get n2
     106/      29 : 53                  		str 	rDStack 							; save where n1 was
     107/      2A : 23                  		dec 	rDStack 							; point r3 back to start
     108/      2B : 23                  		dec 	rDStack
     109/      2C : 8E                  		glo 	re 									; get n1
     110/      2D : 53                  		str 	rDStack
     111/      2E : DC                  		sep 	rc
     112/      2F :                     
     113/      2F :                     ; *********************************************************************************************************************
     114/      2F :                     
     115/      2F :                     FW_BR:												; [[BR]] Unconditional Branch
     116/      2F : 44                  		lda 	rProgram 							; read offset
     117/      30 : 30 38               		br 		__Branch 							; jump into 0BR after the tos = 0 test
     118/      32 :                     
     119/      32 :                     ; *********************************************************************************************************************
     120/      32 :                     
 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 3 - 7/31/2016 21:04:16


     121/      32 :                     FW_0BR: 											; [[0BR]] if pop = 0 then advance by <next> (7 bit signed)
     122/      32 : 44                  		lda 	rProgram 							; read offset into RE.0
     123/      33 : AE                  		plo 	re 
     124/      34 :                     
     125/      34 : 43                  		lda 	rDStack 							; pop value off top of stack
     126/      35 : 3A 59               		bnz 	__Return 							; if non zero, fail. 
     127/      37 :                     
     128/      37 : 8E                  		glo 	re 									; put value onto the data stack as a temporary measure
     129/      38 :                     __Branch:
     130/      38 : 23                  		dec 	rDStack
     131/      39 : 53                  		str 	rDStack
     132/      3A : FA 80               		ani 	080h 								; check bit 7
     133/      3C : 3A 49               		bnz 	__0BR_Backwards 					; if -ve it is a backward jump.
     134/      3E :                     
     135/      3E : 84                  		glo 	rProgram 							; add offset to R4/low
     136/      3F : F4                  		add
     137/      40 : A4                  		plo 	rProgram
     138/      41 : 3B 47               		bnf 	__0BR_Exit
     139/      43 : 94                  		ghi 	rProgram 							; add carry into R4
     140/      44 : FC 01               		adi 	1
     141/      46 :                     __0BR_SaveR41Exit:
     142/      46 : B4                  		phi 	rProgram
     143/      47 :                     __0BR_Exit:
     144/      47 : 13                  		inc 	rDStack 							; drop temp off stack
     145/      48 : DC                  		sep 	rc
     146/      49 :                     
     147/      49 :                     __0BR_Backwards:
     148/      49 : 84                  		glo 	rProgram 							; subtract from R4/Low
     149/      4A : F4                  		add 
     150/      4B : A4                  		plo 	rProgram
     151/      4C : 33 47               		bdf 	__0BR_Exit 							; not borrow, exit.
     152/      4E : 94                  		ghi 	rProgram 							; carry borrow through.
     153/      4F : FF 01               		smi 	1
     154/      51 : 30 46               		br 		__0BR_SaveR41Exit
     155/      53 :                     
     156/      53 :                     
     157/      53 :                     ; *********************************************************************************************************************
     158/      53 :                     
     159/      53 :                     FW_FromR:											; [[R>]] return stack to data stack (1 byte only)
     160/      53 : 42                  		lda 	rRStack
     161/      54 : 30 B5               		br 		_PushD
     162/      56 :                     
     163/      56 :                     ; *********************************************************************************************************************
     164/      56 :                     
     165/      56 :                     FW_ToR:												; [[>R]] data stack to return stack (1 byte only)
     166/      56 : 43                  		lda 	rDStack
     167/      57 : 22                  		dec 	rRStack
     168/      58 : 52                  		str 	rRStack
     169/      59 :                     __Return:
     170/      59 : DC                  		sep 	rc
     171/      5A :                     
     172/      5A :                     ; *********************************************************************************************************************
     173/      5A :                     
     174/      5A :                     FW_Read:	 										; [[@]] read from variable page.
     175/      5A : F0                  		ldx 										; read address 
     176/      5B : A5                  		plo 	rVariables 							; point RVariables to it
     177/      5C : 45                  		lda 	rVariables 							; read rVariables
     178/      5D : 25                  		dec 	rVariables 							; unpick if overflowed.
     179/      5E : 30 B6               		br 		_SaveD 								; and write it out.
     180/      60 :                     
 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 4 - 7/31/2016 21:04:16


     181/      60 :                     ; *********************************************************************************************************************
     182/      60 :                     
     183/      60 :                     FW_Store:											; [[!]] write to variable page.
     184/      60 : 43                  		lda 	rDStack								; read address
     185/      61 : A5                  		plo 	rVariables 							; rVariables points to it
     186/      62 : 43                  		lda 	rDStack 							; read data
     187/      63 : 55                  		str 	rVariables 							; write it.
     188/      64 : DC                  		sep 	rc
     189/      65 :                     
     190/      65 :                     ; *********************************************************************************************************************
     191/      65 :                     
     192/      65 :                     FW_AddStore:										; [[+!]] add tos to memory
     193/      65 : 43                  		lda 	rDStack								; read address
     194/      66 : A5                  		plo 	rVariables 							; rVariables points to it
     195/      67 : 43                  		lda 	rDStack 							; read data
     196/      68 : E5                  		sex 	rVariables
     197/      69 : F4                  		add 										; add to memory
     198/      6A : E3                  		sex 	rDStack
     199/      6B : 55                  		str 	rVariables 							; write it.
     200/      6C : DC                  		sep 	rc
     201/      6D :                     
     202/      6D :                     ; *********************************************************************************************************************
     203/      6D :                     
     204/      6D :                     FW_Inc:												; [[1+]] Increment
     205/      6D : F8 01               		ldi 	1
     206/      6F : 30 7D               		br 		__AddWr
     207/      71 :                     
     208/      71 :                     ; *********************************************************************************************************************
     209/      71 :                     
     210/      71 :                     FW_Dec:												; [[1-]] Increment
     211/      71 : F8 FF               		ldi 	0FFh
     212/      73 : 30 7D               		br 		__AddWr
     213/      75 :                     
     214/      75 :                     ; *********************************************************************************************************************
     215/      75 :                     
     216/      75 :                     FW_ShiftR:											; [[2/]] Shift right
     217/      75 : F0                  		ldx  										; read it
     218/      76 : F6                  		shr 										; shift right
     219/      77 : 30 B6               		br 		_SaveD 								; write back.
     220/      79 :                     
     221/      79 :                     ; *********************************************************************************************************************
     222/      79 :                     
     223/      79 :                     FW_ShiftL:											; [[2*]] Shift left
     224/      79 : F0                  		ldx 										; read tos
     225/      7A : 30 7D               		br 		__AddWr 							; add it to itself.
     226/      7C :                     
     227/      7C :                     ; *********************************************************************************************************************
     228/      7C :                     
     229/      7C :                     FW_Add:												; [[+]] add top of stack values.
     230/      7C : 43                  		lda 	rDStack 							; read TOS
     231/      7D : F4                  __AddWr:add
     232/      7E : 30 B6               		br 		_SaveD
     233/      80 :                     
     234/      80 :                     ; *********************************************************************************************************************
     235/      80 :                     
     236/      80 :                     FW_Sub:												; [[-]] sub top of stack values.
     237/      80 : 43                  		lda 	rDStack 							; read TOS
     238/      81 : F5                  		sd
     239/      82 : 30 B6               		br 		_SaveD
     240/      84 :                     
 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 5 - 7/31/2016 21:04:16


     241/      84 :                     ; *********************************************************************************************************************
     242/      84 :                     
     243/      84 :                     FW_And:												; [[and]] and top of stack values.
     244/      84 : 43                  		lda 	rDStack 							; read TOS
     245/      85 : F2                  		and
     246/      86 : 30 B6               		br 		_SaveD
     247/      88 :                     
     248/      88 :                     ; *********************************************************************************************************************
     249/      88 :                     
     250/      88 :                     FW_Or:												; [[or]] or top of stack values.
     251/      88 : 43                  		lda 	rDStack 							; read TOS
     252/      89 : F1                  		or
     253/      8A : 30 B6               		br 		_SaveD
     254/      8C :                     
     255/      8C :                     ; *********************************************************************************************************************
     256/      8C :                     
     257/      8C :                     FW_Xor:												; [[xor]] xor top of stack values.
     258/      8C : 43                  		lda 	rDStack 							; read TOS
     259/      8D : F3                  		xor
     260/      8E : 30 B6               		br 		_SaveD
     261/      90 :                     
     262/      90 :                     ; *********************************************************************************************************************
     263/      90 :                     
     264/      90 :                     FW_Literal:											; [[LITERAL]], code loads literal to TOS
     265/      90 : 44                  		lda 	rProgram 							; read the literal in
     266/      91 : 30 B5               		br 		_PushD 								; push on stack
     267/      93 :                     
     268/      93 :                     ; *********************************************************************************************************************
     269/      93 :                     
     270/      93 :                     FW_Drop:											; [[DROP]], drops top of stack.
     271/      93 : 43                  		lda 	rDStack 							
     272/      94 : DC                  		sep 	rc
     273/      95 :                     
     274/      95 :                     ; *********************************************************************************************************************
     275/      95 :                     
     276/      95 :                     FW_QDup:											; [[?DUP]] word, duplicate if non zero else drop.
     277/      95 : F0                  		ldx 										; look at TOS
     278/      96 : 32 59               		bz 		__Return 							; if zero leave unchanged, else drop through to DUP.
     279/      98 :                     
     280/      98 :                     ; *********************************************************************************************************************
     281/      98 :                     
     282/      98 :                     FW_Dup:												; [[DUP]], duplicate top of stack
     283/      98 : F0                  		ldx 										; read top of stack.
     284/      99 : 30 B5               		br 		_PushD
     285/      9B :                     
     286/      9B :                     ; *********************************************************************************************************************
     287/      9B :                     
     288/      9B : 13                  FW_Over:inc 	rDStack 							; [[OVER]] point to 2nd value
     289/      9C : F0                  		ldx 										; read value
     290/      9D : 23                  		dec 	rDStack 							; unpick increment
     291/      9E : 30 B5               		br 		_PushD
     292/      A0 :                     
     293/      A0 :                     ; *********************************************************************************************************************
     294/      A0 :                     
     295/      A0 :                     FW_Negate: 											; [[0-]] Word, negates top of stack
     296/      A0 : 43                  		lda 	rDStack
     297/      A1 : 23                  		dec 	rDStack
     298/      A2 : FD 00               		sdi 	0
     299/      A4 : 30 B6               		br 		_SaveD
     300/      A6 :                     
 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 6 - 7/31/2016 21:04:16


     301/      A6 :                     ; *********************************************************************************************************************
     302/      A6 :                     
     303/      A6 :                     FW_EqualZero:										; [[0=]] Word, sets to -1 if TOS zero 0 otherwise.
     304/      A6 : 43                  		lda 	rDStack 							; get TOS
     305/      A7 : 32 BF               		bz 		FW_Minus1 							; if zero, push -1 else push 0 (fall through)
     306/      A9 :                     
     307/      A9 :                     ; *********************************************************************************************************************
     308/      A9 :                     
     309/      A9 :                     FW_0:	
     310/      A9 : 9F                  		ghi 	rf 									; [[0]] Word, pushes 0 on stack.
     311/      AA : 30 B5               		br 		_PushD
     312/      AC :                     
     313/      AC :                     ; *********************************************************************************************************************
     314/      AC :                     
     315/      AC :                     FW_LessZero:										; [[0<]] Word, push 1 if negative else push 0
     316/      AC : 43                  		lda 	rDStack 							; get TOS
     317/      AD : FA 80               		ani 	080h								; look at the sign bit.
     318/      AF : 32 A9               		bz 		FW_0 								; if +ve push 0 else drop through and push 1.
     319/      B1 : 30 BF               		br 		FW_Minus1
     320/      B3 :                     
     321/      B3 :                     ; *********************************************************************************************************************
     322/      B3 :                     
     323/      B3 :                     FW_1:	
     324/      B3 : F8 01               		ldi 	1 									; [[1]] Word, pushes -1 on stack
     325/      B5 :                     
     326/      B5 : 23                  _PushD:	dec 	rDStack 							; push on stack.
     327/      B6 : 53                  _SaveD:	str 	rDStack
     328/      B7 : DC                  		sep 	rc
     329/      B8 :                     
     330/      B8 :                     ; *********************************************************************************************************************
     331/      B8 :                     
     332/      B8 :                     FW_GreaterZero:										; [[0>]] Word, push -1 if >0 else push 0
     333/      B8 : 43                  		lda 	rDStack 							; get value
     334/      B9 : 32 A9               		bz 		FW_0 								; zero returns 0
     335/      BB : FA 80               		ani 	80h									; check bit 7
     336/      BD : 3A A9               		bnz 	FW_0 								; -ve returns 0
     337/      BF :                     
     338/      BF :                     ; *********************************************************************************************************************
     339/      BF :                     
     340/      BF :                     FW_Minus1:	
     341/      BF : F8 FF               		ldi 	0FFh								; [[-1]] Word, pushes -1 on stack.
     342/      C1 : 30 B5               		br 		_PushD
     343/      C3 :                     
     344/      C3 :                     ; *********************************************************************************************************************
     345/      C3 :                     
     346/      C3 :                     FW_Swap:											; [[SWAP]] swap tos values.
     347/      C3 : 43                  		lda 	rDStack 							; read TOS, save in RE.0
     348/      C4 : AE                  		plo 	re
     349/      C5 : F0                  		ldx 										; read new TOS save in RE.1
     350/      C6 : BE                  		phi 	re
     351/      C7 : 8E                  		glo 	re 									; get value that is written
     352/      C8 : 53                  		str 	rDStack
     353/      C9 : 9E                  		ghi 	re 									; get value to push
     354/      CA : 30 B5               		br 		_PushD
     355/      CC :                     
     356/      CC :                     ; *********************************************************************************************************************
     357/      CC :                     
     358/      CC :                     FW_Equals:											; [[=]] check top two values equal
     359/      CC : DD                  		sep 	rd
     360/      CD : 80                  		db 		FW_Sub
 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 7 - 7/31/2016 21:04:16


     361/      CE : A6                  		db 		FW_EqualZero
     362/      CF : 00                  		db 		0 
     363/      D0 :                     
     364/      D0 :                     ; *********************************************************************************************************************
     365/      D0 :                     
     366/      D0 :                     FW_VariablePage:
     367/      D0 : F8 06               		ldi 	dataMemory / 256 					; [[PAGE@]] pushes the page address of variables on the stack.
     368/      D2 : 30 B5               		br 		_PushD
     369/      D4 :                     
     370/      D4 :                     ; *********************************************************************************************************************
     371/      D4 :                     
     372/      D4 :                     FM_SetVariablePage:
     373/      D4 : 43                  		lda 	rDStack 							; [[PAGE!]] sets the variable page from the default.
     374/      D5 : B5                  		phi 	rVariables
     375/      D6 : DC                  		sep 	rc
     376/      D7 :                     
     377/      D7 :                     ; *********************************************************************************************************************
     378/      D7 :                     
     379/      D7 : 30 D7               FW_Stop:br 		FW_Stop								; [[STOP]] word
     380/      D9 :                     
     381/      D9 :                     ; *********************************************************************************************************************
     382/      D9 :                     
     383/      D9 : F8 02               FW_2:	ldi 	2 									; [[2]]
     384/      DB : 30 B5               		br 		_PushD
     385/      DD : F8 03               FW_3:	ldi 	3 									; [[3]]
     386/      DF : 30 B5               		br 		_PushD
     387/      E1 : F8 04               FW_4:	ldi 	4 									; [[4]]
     388/      E3 : 30 B5               		br 		_PushD
     389/      E5 : F8 08               FW_8:	ldi 8 										; [[8]]
     390/      E7 : 30 B5               		br 		_PushD
     391/      E9 : F8 0A               FW_10:	ldi 	10 									; [[10]]
     392/      EB : 30 B5               		br 		_PushD
     393/      ED : F8 10               FW_16:	ldi 16 										; [[16]]
     394/      EF : 30 B5               		br 		_PushD	
     395/      F1 : F8 64               FW_100:	ldi 100 									; [[100]]
     396/      F3 : 30 B5               		br 		_PushD
     397/      F5 :                     
     398/      F5 :                     ; *********************************************************************************************************************
     399/      F5 :                     ;
     400/      F5 :                     ;											Start up uForth interpreter
     401/      F5 :                     ;
     402/      F5 :                     ; *********************************************************************************************************************
     403/      F5 :                     
     404/      F5 : 90                  Boot:	ghi 	r0 									; reset counter
     405/      F6 : BB                  		phi 	rCounter 							
     406/      F7 : AB                  		plo 	rCounter
     407/      F8 :                     
     408/      F8 : F8 FE               		ldi 	0FEh 								; reset return stack to end of data page, minus 1 for random seed.
     409/      FA : A2                  		plo 	rRStack
     410/      FB : F8 06               		ldi 	dataMemory / 256 					; set high address for the stacks and variable area (same page)
     411/      FD : B2                  		phi 	rRStack											
     412/      FE : B3                  		phi 	rDStack
     413/      FF : B5                  		phi 	rVariables
     414/     100 :                     
     415/     100 : 90                  		ghi 	r0 									; set up RF,RC,RD,R1 relies on all being in the same page as this.
     416/     101 : B1                  		phi 	rInterrupt
     417/     102 : BC                  		phi 	rc
     418/     103 : BD                  		phi 	rd
     419/     104 : BF                  		phi 	rf
     420/     105 :                     
 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 8 - 7/31/2016 21:04:16


     421/     105 : F8 F5               		ldi 	ProgramCode & 255 					; RF now points to the address of the start
     422/     107 : AF                  		plo 	rf
     423/     108 : 4F                  		lda 	rf 									; read start address of program into R4.
     424/     109 : B4                  		phi 	rProgram
     425/     10A : 4F                  		lda 	rf
     426/     10B : A4                  		plo 	rProgram 						
     427/     10C : 4F                  		lda 	rf 									; read data stack top, and set up that stack.
     428/     10D : A3                  		plo 	rDStack
     429/     10E :                     
     430/     10E : F8 19               		ldi 	ExecuteCompiledWord & 255			; RC points to the code to execute the word at R4.
     431/     110 : AC                  		plo 	rc
     432/     111 : F8 35               		ldi 	ExecuteDefinedWord & 255 			; RD points to the code to execute a new definition.
     433/     113 : AD                  		plo 	rd
     434/     114 : F8 44               		ldi 	Interrupt & 255						; R1 points to the interrupt routine.
     435/     116 : A1                  		plo 	rInterrupt
     436/     117 :                     
     437/     117 : E3                  		sex  	rDStack 							; R3 points to data stack.
     438/     118 : DC                  		sep 	rc 									; and start.
     439/     119 :                     
     440/     119 :                     ; *************************************************************************************************************************
     441/     119 :                     ;
     442/     119 :                     ;	Execute the word at (R4). This is either a 1 byte call (00-F7) or a 2 byte call (F8-FF) nn
     443/     119 :                     ;	Runs in RC.
     444/     119 :                     ;
     445/     119 :                     ; *************************************************************************************************************************
     446/     119 :                     
     447/     119 :                     ExecuteCompiledWord:
     448/     119 : 44                  		lda 	rProgram 							; get the next instruction to execute.
     449/     11A : FC 08               		adi 	8 									; will cause a carry (DF = 1) for F8-FF
     450/     11C : 33 29               		bdf 	ECW_LongAddress 					; which means it's a long address
     451/     11E :                     
     452/     11E : FF 08               		smi 	8 									; fix back to original value
     453/     120 : 32 2F               		bz 		ECW_Return 							; if it was $00 that's a return.
     454/     122 : AF                  		plo 	rf 									; put in RF.0
     455/     123 : F8 00               		ldi 	0 									; set RF.1 to zero. RF now points to $000-$0F7.
     456/     125 : BF                  		phi 	rf 									
     457/     126 : DF                  		sep 	rf 									; run whatever is there.
     458/     127 : 30 19               		br 		ExecuteCompiledWord 				; and when finished, do the next instruction.		
     459/     129 :                     ;
     460/     129 :                     ECW_LongAddress:									; 11 bit address
     461/     129 : BF                  		phi 	rf 									; it will be 00-07 after the add, so this is the upper byte in RF.1
     462/     12A : 44                  		lda 	rProgram 							; get the lower byte
     463/     12B : AF                  		plo 	rf 									; put in RF.0
     464/     12C : DF                  		sep 	rf 									; run whatever is there.
     465/     12D : 30 19               		br 		ExecuteCompiledWord 				; and when finished, do the next instruction.		
     466/     12F :                     ;
     467/     12F :                     ECW_Return:
     468/     12F : 42                  		lda 	rRStack 							; retrieve the saved return address and put back in R4
     469/     130 : A4                  		plo 	rProgram
     470/     131 : 42                  		lda 	rRStack
     471/     132 : B4                  		phi 	rProgram
     472/     133 : 30 19               		br 		ExecuteCompiledWord 				; and go do it.
     473/     135 :                     
     474/     135 :                     ; *************************************************************************************************************************
     475/     135 :                     ;
     476/     135 :                     ;	If the word executed via the SEP RFs is a compiled word, it will execute and be ended via SEP RC, which will execute
     477/     135 :                     ; 	the next word. 
     478/     135 :                     ;
     479/     135 :                     ;	If it is a sequence of commands the first instruction will be SEP RD, which will come here (with RF pointing to the
     480/     135 :                     ;	new code to execute)
 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 9 - 7/31/2016 21:04:16


     481/     135 :                     ;
     482/     135 :                     ; *************************************************************************************************************************
     483/     135 :                     
     484/     135 :                     ExecuteDefinedWord:
     485/     135 : 22                  		dec 	rRStack 							; push R4, the program pointer on the return stack
     486/     136 : 94                  		ghi 	rProgram
     487/     137 : 52                  		str 	rRStack
     488/     138 : 22                  		dec 	rRStack
     489/     139 : 84                  		glo 	rProgram
     490/     13A : 52                  		str 	rRStack
     491/     13B :                     
     492/     13B : 9F                  		ghi 	rf 									; it was run in R4 (the SEP RD command), so RD will contain the next
     493/     13C : B4                  		phi 	rProgram 							; instruction, which we copy into R4
     494/     13D : 8F                  		glo 	rf
     495/     13E : A4                  		plo 	rProgram
     496/     13F : DC                  		sep 	rc 									; and run "ExecuteCompiledWord"
     497/     140 : 30 35               		br 		ExecuteDefinedWord 					; this is re-entrant.
     498/     142 :                     
     499/     142 :                     ; *************************************************************************************************************************
     500/     142 :                     ;										Interrupt Routine (FRED version)
     501/     142 :                     ; *************************************************************************************************************************
     502/     142 :                     
     503/     142 :                     Return:	
     504/     142 : 42                  		lda 	rRStack 							; pop D
     505/     143 : 70                  		ret 										; pop XP
     506/     144 :                     Interrupt:
     507/     144 : 22                  		dec 	rRStack 							; save XP
     508/     145 : 78                  		sav
     509/     146 : 22                  		dec 	rRStack 							; save D
     510/     147 : 52                  		str 	rRStack
     511/     148 :                     
     512/     148 : F8 00               		ldi 	videoMemory & 255 					; set up R0
     513/     14A : A0                  		plo 	r0
     514/     14B : F8 07               		ldi 	videoMemory / 256
     515/     14D : B0                  		phi 	r0
     516/     14E : 1B                  		inc 	rCounter 							; bump the timer counter.
     517/     14F : 30 42               		br 		Return 		
     518/     151 :                     
     519/     151 :                     ; *************************************************************************************************************************
     520/     151 :                     ;
     521/     151 :                     ;										Draw Digit x y n autoreturns
     522/     151 :                     ;
     523/     151 :                     ; *************************************************************************************************************************
     524/     151 :                     
     525/     151 :                     FW_DrawDigit:
     526/     151 : 43                  		lda 	rDStack 							; get digit [[DIGIT]]
     527/     152 : 23                  		dec 	rDStack
     528/     153 : F4                  		add 										; x 2
     529/     154 : F4                  		add 										; x 3
     530/     155 : 53                  		str 	rDStack 									
     531/     156 : F4                  		add 										; x 6
     532/     157 : FC AB               		adi 	FontData & 255
     533/     159 : A4                  		plo 	rProgram
     534/     15A : F8 01               		ldi 	FontData / 256
     535/     15C : B4                  		phi 	rProgram
     536/     15D : 13                  		inc 	rDStack 
     537/     15E :                     
     538/     15E :                     ; *************************************************************************************************************************
     539/     15E :                     ;
     540/     15E :                     ;												Draw Sprite routine
 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 10 - 7/31/2016 21:04:16


     541/     15E :                     ;
     542/     15E :                     ;	Note: if used on a 1802 the bit shifting can be simplified using the 1802's ring shift. A 1801 only has a shift
     543/     15E :                     ;	right into DF, so in a 1801 you have two seperate bits of code for the 16 bit shift.
     544/     15E :                     ; *************************************************************************************************************************
     545/     15E :                     
     546/     15E :                     FW_DrawSprite:										; [[SPRITE]] y x sprite
     547/     15E : 43                  		lda 	rDStack 							; get Y
     548/     15F : 23                  		dec 	rDStack 							; X = DStack = Y
     549/     160 : F4                  		add 										; D = Y * 2
     550/     161 : 53                  		str 	rDStack
     551/     162 : F4                  		add 										; D = Y * 4
     552/     163 : 53                  		str 	rDStack
     553/     164 : F4                  		add 										; D = Y * 8
     554/     165 : A6                  		plo 	r6 									; R6.0 = Y * 8
     555/     166 : 13                  		inc 	rDStack 							; drop Y
     556/     167 :                     
     557/     167 : 43                  		lda 	rDStack 							; fetch X
     558/     168 : B7                  		phi 	r7 									; save in R7.1 this is used for the shift count.
     559/     169 : F6                  		shr
     560/     16A : F6                  		shr
     561/     16B : F6                  		shr 										; divide by 8.
     562/     16C : 23                  		dec 	rDStack 							; save on DStack address
     563/     16D : 53                  		str 	rDStack
     564/     16E : 86                  		glo 	r6 									; add Y * 8 to it
     565/     16F : F4                  		add
     566/     170 : A6                  		plo 	r6 									
     567/     171 : F8 07               		ldi 	videoMemory / 256 					; R6 points to video RAM write byte
     568/     173 : B6                  		phi 	r6
     569/     174 :                     
     570/     174 : 44                  		lda 	rProgram 							; get the sprite size, it is 8 x n
     571/     175 : A7                  		plo 	r7 									; R7.0 is the count of lines.
     572/     176 : 32 A5               		bz 		__SDExit 							; if line count is zero exit.
     573/     178 : E6                  		sex 	r6 									; we use X = 6 to access video memory.
     574/     179 :                     __SDLineLoop:
     575/     179 :                     
     576/     179 : 44                  		lda 	rProgram 							; R8 is the byte shifting graphic
     577/     17A : B8                  		phi 	r8
     578/     17B : F8 00               		ldi 	0
     579/     17D : A8                  		plo 	r8 
     580/     17E :                     
     581/     17E : 97                  		ghi 	r7 									; get original X value
     582/     17F : FA 07               		ani 	7 									; look at lower 3 bits, which is the right-shift
     583/     181 : 32 96               		bz 		__SDXorScreen 						; if zero no shift required
     584/     183 : A9                  		plo 	r9 									; R9.0 is the shift counter
     585/     184 :                     __SDShiftRight:
     586/     184 : 98                  		ghi 	r8 									; shift R8.1 right 
     587/     185 : F6                  		shr
     588/     186 : B8                  		phi 	r8
     589/     187 : 33 8D               		bdf 	__SDShiftRight1 					; if Df set need to shift a 1 into R8.0
     590/     189 : 88                  		glo 	r8
     591/     18A : F6                  		shr
     592/     18B : 30 91               		br 		__SDShiftDone 
     593/     18D :                     ;
     594/     18D :                     __SDShiftRight1: 									; we have to do it this way, 1801 as now Ring Shift
     595/     18D : 88                  		glo 	r8 									; this one shifts a 1 in as the MSB - the code immediately
     596/     18E : F6                  		shr 										; above shifts a 0 in as the MSB.
     597/     18F : F9 80               		ori 	080h
     598/     191 :                     
     599/     191 :                     __SDShiftDone:
     600/     191 : A8                  		plo 	r8 									; write low byte back
 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 11 - 7/31/2016 21:04:16


     601/     192 : 29                  		dec 	r9 									; do it the relevant number of times.
     602/     193 : 89                  		glo 	r9
     603/     194 : 3A 84               		bnz 	__SDShiftRight
     604/     196 :                     
     605/     196 :                     __SDXorScreen:
     606/     196 : 98                  		ghi 	r8 									; do high byte
     607/     197 : F3                  		xor
     608/     198 : 56                  		str 	r6
     609/     199 : 16                  		inc 	r6
     610/     19A : 88                  		glo 	r8 									; do low byte.
     611/     19B : F3                  		xor 
     612/     19C : 56                  		str 	r6
     613/     19D :                     
     614/     19D : 86                  		glo 	r6 									; next line down.
     615/     19E : FC 07               		adi 	7
     616/     1A0 : A6                  		plo 	r6
     617/     1A1 :                     
     618/     1A1 : 27                  		dec 	r7 									; decrement line count.
     619/     1A2 : 87                  		glo 	r7
     620/     1A3 : 3A 79               		bnz 		__SDLineLoop
     621/     1A5 :                     
     622/     1A5 :                     __SDExit:
     623/     1A5 : F8 2F               		ldi 	ECW_Return & 255					; this forces a RETURN to be executed
     624/     1A7 : AC                  		plo 	rc
     625/     1A8 : E3                  		sex 	rDStack 							; X is back at rDStack
     626/     1A9 : 13                  		inc 	rDStack 							; fix up data stack.
     627/     1AA : DC                  		sep 	rc
     628/     1AB :                     
     629/     1AB :                     ; *************************************************************************************************************************
     630/     1AB :                     ;
     631/     1AB :                     ;														FontData
     632/     1AB :                     ;
     633/     1AB :                     ; *************************************************************************************************************************
     634/     1AB :                     
     635/     1AB :                     FontData:
     636/     1AB : 05 70 88 88 88 70   		db 	5,070h,088h,088h,088h,070h 				; 0
     637/     1B1 : 05 20 60 20 20 F8   		db 	5,020h,060h,020h,020h,0F8h 				; 1
     638/     1B7 : 05 F0 08 70 80 F8   		db 	5,0F0h,008h,070h,080h,0F8h 				; 2
     639/     1BD : 05 70 88 38 88 70   		db 	5,070h,088h,038h,088h,070h 				; 3
     640/     1C3 : 05 30 50 F8 10 10   		db 	5,030h,050h,0F8h,010h,010h 				; 4
     641/     1C9 : 05 F8 80 F0 08 F0   		db 	5,0F8h,080h,0F0h,008h,0F0h 				; 5
     642/     1CF : 05 70 80 F0 88 70   		db 	5,070h,080h,0F0h,088h,070h 				; 6
     643/     1D5 : 05 F8 08 10 20 40   		db 	5,0F8h,008h,010h,020h,040h 				; 7
     644/     1DB : 05 70 88 70 88 70   		db 	5,070h,088h,070h,088h,070h 				; 8
     645/     1E1 : 05 70 88 78 08 70   		db 	5,070h,088h,078h,008h,070h 				; 9
     646/     1E7 :                     
     647/     1E7 :                     			
     648/     1E7 :                     ; *************************************************************************************************************************
     649/     1E7 :                     ;
     650/     1E7 :                     ;												Clear the video display
     651/     1E7 :                     ;
     652/     1E7 :                     ; *************************************************************************************************************************
     653/     1E7 :                     
     654/     1E7 :                     FW_ClearScreen: 									; [[CLEARSCREEN]]
     655/     1E7 : F8 00               		ldi 	0
     656/     1E9 : A6                  		plo 	r6
     657/     1EA : F8 07               		ldi 	videoMemory / 256
     658/     1EC : B6                  		phi 	r6
     659/     1ED :                     __CLSLoop:
     660/     1ED : F8 00               		ldi 	0
 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 12 - 7/31/2016 21:04:16


     661/     1EF : 56                  		str 	r6
     662/     1F0 : 16                  		inc 	r6
     663/     1F1 : 86                  		glo 	r6
     664/     1F2 : 3A ED               		bnz 	__CLSLoop
     665/     1F4 : DC                  		sep 	rc
     666/     1F5 :                     
     667/     1F5 :                     ; *************************************************************************************************************************
     668/     1F5 :                     ;
     669/     1F5 :                     ;		The first three bytes are the address of the first word to run, and the data stack initial value.
     670/     1F5 :                     ;
     671/     1F5 :                     ; *************************************************************************************************************************
     672/     1F5 :                     
     673/     1F5 :                     ProgramCode:
     674/     1F5 : 02 25               		dw 		Start 								; [[$$STARTMARKER]] address of program start, not actually a word that can be called.
     675/     1F7 : A0                  		db 		0A0h 								; data stack starts here in variable page (and works down)
     676/     1F8 :                     
     677/     1F8 :                     ; *************************************************************************************************************************
     678/     1F8 :                     ;		
     679/     1F8 :                     ;										Read Keyboard. Return FF no key, else 00-1F
     680/     1F8 :                     ;
     681/     1F8 :                     ; *************************************************************************************************************************
     682/     1F8 :                     
     683/     1F8 :                     FW_KeyRead:											; [[INKEY]]
     684/     1F8 : 23                  		dec 	rDStack
     685/     1F9 : 3C FD               		bn1 	__KRPushExit
     686/     1FB : 68                  		db 		068h 								; INP 0 not supported in 1802 assembly language
     687/     1FC : DC                  		sep 	rc
     688/     1FD :                     __KRPushExit:
     689/     1FD : F8 FF               		ldi 	0FFh
     690/     1FF : 53                  		str 	rDStack
     691/     200 : DC                  		sep 	rc
     692/     201 :                     
     693/     201 :                     ; *************************************************************************************************************************
     694/     201 :                     ;
     695/     201 :                     ;													Sound Player 
     696/     201 :                     ;
     697/     201 :                     ; *************************************************************************************************************************
     698/     201 :                     
     699/     201 :                     FW_Sound: 											; [[BEEP]]
     700/     201 : 43                          lda 	rDStack 							; read the length
     701/     202 : A6                          plo 	r6 									; save in R6.0
     702/     203 : 43                          lda 	rDStack 							; read the pitch 
     703/     204 : B6                          phi 	r6 									; save in R6.1
     704/     205 :                     FW_ToneLoop:     
     705/     205 : EF                  		sex 	rf 									; run this in RF
     706/     206 : 63                          out     AudioPort
     707/     207 : 05                          db      5
     708/     208 : 96                          ghi     r6 									; get the pitch.
     709/     209 :                     FM_TimeLoop
     710/     209 : FF 01                       smi     1                                   ; short delay loop
     711/     20B : 3A 09                       bnz     FM_TimeLoop
     712/     20D : 63                          out  	AudioPort                           ; reset speaker line.
     713/     20E : 01                          db     	1                                                
     714/     20F : 26                          dec     r6                                  ; done it correct number of times
     715/     210 : 86                          glo 	r6
     716/     211 : 3A 05                       bnz 	FW_ToneLoop
     717/     213 : E3                          sex 	rDStack 							; fix X Back
     718/     214 : DC                          sep 	rc 									; and exit
     719/     215 :                     
     720/     215 :                     ; *************************************************************************************************************************
 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 13 - 7/31/2016 21:04:16


     721/     215 :                     ;
     722/     215 :                     ;												Random Number generator
     723/     215 :                     ;
     724/     215 :                     ; *************************************************************************************************************************
     725/     215 :                     
     726/     215 :                     FW_Random:											; [[RANDOM]]
     727/     215 : F8 FF               		ldi 	0FFh								; point R5 (rVariables) to $FF the seed
     728/     217 : A5                  		plo 	rVariables
     729/     218 : E5                  		sex 	rVariables 							; X points to it
     730/     219 : 8B                  		glo 	rCounter 							; Xor with counter
     731/     21A : F3                  		xor
     732/     21B : F6                  		shr 										; shift right.
     733/     21C : 33 20               		bdf 	FW_NoXor
     734/     21E : FB B4               		xri 	0B4h
     735/     220 :                     FW_NoXor:
     736/     220 : E3                  		sex 	rDStack
     737/     221 : 55                  		str 	rVariables
     738/     222 : 23                  		dec 	rDStack 							; push on stack
     739/     223 : 53                  		str 	rDStack 
     740/     224 : DC                  		sep 	rc
     741/     225 :                     
     742/     225 :                     ; *************************************************************************************************************************
     743/     225 :                     ;
     744/     225 :                     ;											Put any long words at this point
     745/     225 :                     ;
     746/     225 :                     ; *************************************************************************************************************************
     747/     225 :                     
     748/     225 :                     Start:												; [[$$TOPKERNEL]] it will trim these off.
     749/     225 : D9 B3 06            		db  FW_2,FW_1,FW_Out 						; screen on.
     750/     228 : DD D9 06            		db 	FW_3,FW_2,FW_Out
     751/     22B : B3 B3 06            		db  FW_1,FW_1,FW_Out 						; keyboard on.
     752/     22E : B3 D9 06            		db 	FW_1,FW_2,FW_Out
     753/     231 :                     
     754/     231 : FA 15               		dw 	FW_Random|0F800h
     755/     233 : 93                  		db  FW_Drop
     756/     234 : 2F FB               		db 	FW_Br,-5
     757/     236 :                     
     758/     236 : ED BF               		db 	FW_16,FW_Minus1
     759/     238 : FA 01               		dw 	FW_Sound |0F800h
     760/     23A :                     
     761/     23A : 90 01 90 01 90 00   		db 	FW_Literal,1,FW_Literal,1,FW_Literal,0
     762/     240 : FA 8B               		dw 	FW_Drawer|0F800h
     763/     242 : 90 0B 90 01 90 01   		db 	FW_Literal,11,FW_Literal,1,FW_Literal,1
     764/     248 : FA 8B               		dw 	FW_Drawer|0F800h
     765/     24A : 90 15 90 01 90 02   		db 	FW_Literal,21,FW_Literal,1,FW_Literal,2
     766/     250 : FA 8B               		dw 	FW_Drawer|0F800h
     767/     252 : 90 1F 90 01 90 03   		db 	FW_Literal,31,FW_Literal,1,FW_Literal,3
     768/     258 : FA 8B               		dw 	FW_Drawer|0F800h
     769/     25A : 90 29 90 01 90 04   		db 	FW_Literal,41,FW_Literal,1,FW_Literal,4
     770/     260 : FA 8B               		dw 	FW_Drawer|0F800h
     771/     262 : 90 01 90 0B 90 05   		db 	FW_Literal,1,FW_Literal,11,FW_Literal,5
     772/     268 : FA 8B               		dw 	FW_Drawer|0F800h
     773/     26A : 90 0B 90 0B 90 06   		db 	FW_Literal,11,FW_Literal,11,FW_Literal,6
     774/     270 : FA 8B               		dw 	FW_Drawer|0F800h
     775/     272 : 90 15 90 0B 90 07   		db 	FW_Literal,21,FW_Literal,11,FW_Literal,7
     776/     278 : FA 8B               		dw 	FW_Drawer|0F800h
     777/     27A : 90 1F 90 0B 90 08   		db 	FW_Literal,31,FW_Literal,11,FW_Literal,8
     778/     280 : FA 8B               		dw 	FW_Drawer|0F800h
     779/     282 : 90 29 90 0B 90 09   		db 	FW_Literal,41,FW_Literal,11,FW_Literal,9
     780/     288 : FA 8B               		dw 	FW_Drawer|0F800h
 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 14 - 7/31/2016 21:04:16


     781/     28A : D7                  		db 	FW_Stop
     782/     28B :                     
     783/     28B :                     FW_Drawer:
     784/     28B : DD                  		sep rd
     785/     28C : F9 51               		dw  FW_DrawDigit|0F800h
     786/     28E :                     
 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 15 - 7/31/2016 21:04:16


  symbol table (* = unused):
  ------------------------

*ARCHITECTURE :  i386-unknown-win32 - |  AUDIOPORT :                      3 - |
*BIGENDIAN :                      0 - |  BOOT :                          F5 C |
*BRANCHEXT :                      0 - | *CASESENSITIVE :                  0 - |
*CONSTPI :        3.141592653589793 - |  DATAMEMORY :                   600 - |
*DATE :                   7/31/2016 - |  ECW_LONGADDRESS :              129 C |
 ECW_RETURN :                   12F C |  EXECUTECOMPILEDWORD :          119 C |
 EXECUTEDEFINEDWORD :           135 C | *FALSE :                          0 - |
*FM_SETVARIABLEPAGE :            D4 C |  FM_TIMELOOP :                  209 C |
 FONTDATA :                     1AB C | *FULLPMMU :                       1 - |
 FW_0 :                          A9 C | *FW_0BR :                        32 C |
 FW_1 :                          B3 C | *FW_10 :                         E9 C |
*FW_100 :                        F1 C |  FW_16 :                         ED C |
 FW_2 :                          D9 C |  FW_3 :                          DD C |
*FW_4 :                          E1 C | *FW_8 :                          E5 C |
*FW_ADD :                        7C C | *FW_ADDSTORE :                   65 C |
*FW_AND :                        84 C |  FW_BR :                         2F C |
*FW_CLEARSCREEN :               1E7 C | *FW_DEC :                        71 C |
 FW_DRAWDIGIT :                 151 C |  FW_DRAWER :                    28B C |
*FW_DRAWSPRITE :                15E C |  FW_DROP :                       93 C |
*FW_DUP :                        98 C | *FW_EQUALS :                     CC C |
 FW_EQUALZERO :                  A6 C | *FW_FROMR :                      53 C |
*FW_GREATERZERO :                B8 C | *FW_IN :                          2 C |
*FW_INC :                        6D C |  FW_IO :                          8 C |
*FW_KEYREAD :                   1F8 C | *FW_LESSZERO :                   AC C |
 FW_LITERAL :                    90 C |  FW_MINUS1 :                     BF C |
*FW_NEGATE :                     A0 C |  FW_NOXOR :                     220 C |
*FW_OR :                         88 C |  FW_OUT :                         6 C |
*FW_OVER :                       9B C | *FW_PICK :                       17 C |
*FW_QDUP :                       95 C |  FW_RANDOM :                    215 C |
*FW_READ :                       5A C | *FW_ROT :                        1F C |
*FW_SHIFTL :                     79 C | *FW_SHIFTR :                     75 C |
 FW_SOUND :                     201 C |  FW_STOP :                       D7 C |
*FW_STORE :                      60 C |  FW_SUB :                        80 C |
*FW_SWAP :                       C3 C |  FW_TONELOOP :                  205 C |
*FW_TOR :                        56 C | *FW_VARIABLEPAGE :               D0 C |
*FW_XOR :                        8C C | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - | *INEXTMODE :                      0 - |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
 INTERRUPT :                    144 C | *LISTON :                         1 - |
*MACEXP :                         1 - | *MOMCPU :                      1802 - |
*MOMCPUNAME :                  1802 - | *NESTMAX :                      100 - |
*PACKING :                        0 - | *PADDING :                        1 - |
 PROGRAMCODE :                  1F5 C |  R0 :                             0 - |
 R6 :                             6 - |  R7 :                             7 - |
 R8 :                             8 - |  R9 :                             9 - |
*RA :                             A - |  RC :                             C - |
 RCOUNTER :                       B - |  RD :                             D - |
 RDSTACK :                        3 - |  RE :                             E - |
*RELAXED :                        0 - |  RETURN :                       142 C |
 RF :                             F - |  RINTERRUPT :                     1 - |
 RPROGRAM :                       4 - |  RRSTACK :                        2 - |
 RVARIABLES :                     5 - |  START :                        225 C |
*TIME :                    21:04:16 - | *TRUE :                           1 - |
*VERSION :                     142F - |  VIDEOMEMORY :                  700 - |
 _PUSHD :                        B5 C |  _SAVED :                        B6 C |
 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 16 - 7/31/2016 21:04:16


 __0BR_BACKWARDS :               49 C |  __0BR_EXIT :                    47 C |
 __0BR_SAVER41EXIT :             46 C |  __ADDWR :                       7D C |
 __BRANCH :                      38 C |  __CLSLOOP :                    1ED C |
 __IO_DOIT :                     16 C |  __KRPUSHEXIT :                 1FD C |
 __RETURN :                      59 C |  __SDEXIT :                     1A5 C |
 __SDLINELOOP :                 179 C |  __SDSHIFTDONE :                191 C |
 __SDSHIFTRIGHT :               184 C |  __SDSHIFTRIGHT1 :              18D C |
 __SDXORSCREEN :                196 C |

    129 symbols
     63 unused symbols

 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 17 - 7/31/2016 21:04:16


  defined macros:
  ---------------

LRI                                   |

      1 macro

 AS V1.42 Beta [Bld 102] - source file uforth.asm - page 18 - 7/31/2016 21:04:16


  codepages:
  ----------

STANDARD (0 changed characters)


0.01 seconds assembly time

    786 lines source file
      2 passes
      0 errors
      0 warnings
